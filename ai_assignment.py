# -*- coding: utf-8 -*-
"""AI assignment

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1GO_8N6zwtiBtmJz79DJemFoa4f5jGlek
"""

# Import necessary libraries
import pandas as pd

# Load datasets
google_review_data = pd.read_csv('GoogleReview_data_cleaned.csv')
tripadvisor_data = pd.read_csv('TripAdvisor_data_cleaned.csv')

# Clean datasets
google_review_data.dropna(axis=0, how='any', inplace=True)
tripadvisor_data.dropna(axis=0, how='any', inplace=True)
google_review_data.drop_duplicates(inplace=True, keep=False)
tripadvisor_data.drop_duplicates(inplace=True, keep=False)

# Add Number of Reviews if not present (this can be refined depending on actual data structure)
if 'Number of Reviews' not in google_review_data.columns:
    google_review_data['Number of Reviews'] = google_review_data['Review'].apply(lambda x: len(x.split()))  # Example assumption
if 'Number of Reviews' not in tripadvisor_data.columns:
    tripadvisor_data['Number of Reviews'] = tripadvisor_data['Review'].apply(lambda x: len(x.split()))  # Example assumption

# Merge datasets on 'Restaurant' and 'Location'
combined_data = pd.merge(google_review_data, tripadvisor_data, on=['Restaurant', 'Location'], how='inner')

# Drop duplicate restaurants
combined_data = combined_data.drop_duplicates(subset=['Restaurant'], keep='first')

# Calculate combined rating (average of ratings from both sources)
combined_data['Combined Rating'] = (combined_data['Rating_x'] + combined_data['Rating_y']) / 2

# Calculate total number of reviews from both sources
combined_data['Total Reviews'] = combined_data['Number of Reviews_x'] + combined_data['Number of Reviews_y']

# Filter data based on the selected location
place = 'KL'  # Example location; replace with user input or any other location
place_df = combined_data[combined_data['Location'].str.lower().str.contains(place.lower())]

# Sort by total reviews and average rating (popularity-based filtering)
sorted_data = place_df.sort_values(by=['Total Reviews', 'Combined Rating'], ascending=[False, False])

# Display the top 10 most popular restaurants
popular_restaurants = sorted_data[['Restaurant', 'Location', 'Total Reviews', 'Combined Rating']].head(10)

# Rename columns for better display
popular_restaurants = popular_restaurants.rename(columns={
    'Restaurant': 'Restaurant Name',
    'Total Reviews': 'Number of Reviews',
    'Combined Rating': 'Average Rating'
})

# Display the popularity-based restaurants
popular_restaurants

# Import necessary libraries
import pandas as pd
import ipywidgets as widgets
from IPython.display import display

# Load datasets
google_review_data = pd.read_csv('GoogleReview_data_cleaned.csv')
tripadvisor_data = pd.read_csv('TripAdvisor_data_cleaned.csv')

# Clean datasets
google_review_data.dropna(axis=0, how='any', inplace=True)
tripadvisor_data.dropna(axis=0, how='any', inplace=True)
google_review_data.drop_duplicates(inplace=True, keep=False)
tripadvisor_data.drop_duplicates(inplace=True, keep=False)

# Add Number of Reviews if not present (this can be refined depending on actual data structure)
if 'Number of Reviews' not in google_review_data.columns:
    google_review_data['Number of Reviews'] = google_review_data['Review'].apply(lambda x: len(x.split()))  # Example assumption
if 'Number of Reviews' not in tripadvisor_data.columns:
    tripadvisor_data['Number of Reviews'] = tripadvisor_data['Review'].apply(lambda x: len(x.split()))  # Example assumption

# Merge datasets on 'Restaurant' and 'Location'
combined_data = pd.merge(google_review_data, tripadvisor_data, on=['Restaurant', 'Location'], how='inner')

# Drop duplicate restaurants
combined_data = combined_data.drop_duplicates(subset=['Restaurant'], keep='first')

# Calculate combined rating (average of ratings from both sources)
combined_data['Combined Rating'] = (combined_data['Rating_x'] + combined_data['Rating_y']) / 2

# Calculate total number of reviews from both sources
combined_data['Total Reviews'] = combined_data['Number of Reviews_x'] + combined_data['Number of Reviews_y']

# Define the function to update the display based on selected location and number of top results
def update_display(location, top_n):
    try:
        top_n = int(top_n)  # Ensure the input is an integer
        if top_n <= 0:
            raise ValueError("Number of top results must be greater than zero.")

        place_df = combined_data[combined_data['Location'].str.lower().str.contains(location.lower())]
        # Sort first by Average Rating (desc) and then by Number of Reviews (desc)
        sorted_data = place_df.sort_values(by=['Combined Rating', 'Total Reviews'], ascending=[False, False])
        popular_restaurants = sorted_data[['Restaurant', 'Location', 'Total Reviews', 'Combined Rating']].head(top_n)
        popular_restaurants = popular_restaurants.rename(columns={
            'Restaurant': 'Name',
            'Total Reviews': 'Number of Reviews',
            'Combined Rating': 'Average Rating'
        })
        # Add a column for ranking starting from 1
        popular_restaurants.reset_index(drop=True, inplace=True)  # Ensure the default index is dropped
        popular_restaurants.index += 1  # Start ranking from 1
        popular_restaurants.index.name = 'Rank'

        # Display the DataFrame with only Rank, Name, Location, Number of Reviews, and Average Rating
        display(popular_restaurants[['Name', 'Location', 'Number of Reviews', 'Average Rating']].reset_index())

    except ValueError as e:
        print(f"Error: {e}")

# Create a dropdown menu for location selection
locations = ['Ipoh', 'JB', 'KL', 'Kuching', 'Langkawi', 'Melaka', 'Miri', 'Penang', 'Petaling Jaya', 'Shah Alam']
dropdown_location = widgets.Dropdown(
    options=locations,
    value='KL',  # Default value
    description='Location:',
)

# Create a text input for number of top results
text_input_top_n = widgets.Text(
    value='10',  # Default value
    description='Top N:',
    style={'description_width': 'initial'}
)

# Display the widgets and link them to the update_display function
widgets.interactive(update_display, location=dropdown_location, top_n=text_input_top_n)

import pandas as pd
import ipywidgets as widgets
from IPython.display import display, HTML

# Load the GoogleReview and TripAdvisor datasets
google_review_data = pd.read_csv('GoogleReview_data_cleaned.csv')
tripadvisor_data = pd.read_csv('TripAdvisor_data_cleaned.csv')

# Clean datasets
google_review_data.dropna(axis=0, how='any', inplace=True)
tripadvisor_data.dropna(axis=0, how='any', inplace=True)
google_review_data.drop_duplicates(inplace=True, keep='first')
tripadvisor_data.drop_duplicates(inplace=True, keep='first')

# Add 'Number of Reviews' columns if not present in the datasets
if 'Number of Reviews' not in google_review_data.columns:
    google_review_data['Number of Reviews'] = google_review_data['Review'].apply(lambda x: len(x.split()) if isinstance(x, str) else 0)
if 'Number of Reviews' not in tripadvisor_data.columns:
    tripadvisor_data['Number of Reviews'] = tripadvisor_data['Review'].apply(lambda x: len(x.split()) if isinstance(x, str) else 0)

# Map the location to the respective CSV file
location_csv_map = {
    'Ipoh': 'Restaurants_Ipoh.csv',
    'JB': 'Restaurants_JB.csv',
    'KL': 'Restaurants_KL.csv',
    'Kuching': 'Restaurants_Kuching.csv',
    'Langkawi': 'Restaurants_Langkawi.csv',
    'Melaka': 'Restaurants_Melaka.csv',
    'Miri': 'Restaurants_Miri.csv',
    'Penang': 'Restaurants_Penang.csv',
    'Petaling Jaya': 'Restaurants_Petaling Jaya.csv',
    'Shah Alam': 'Restaurants_Shah Alam.csv'
}

# Define a function to update and display the data
def update_display(location, top_n, min_rating, max_rating):
    try:
        # Load the location-specific restaurant data
        location_file = location_csv_map.get(location)
        if not location_file:
            print("Invalid location.")
            return

        # Load the restaurant data for the selected location
        location_restaurant_data = pd.read_csv(location_file)

        # Ensure that the user input is valid
        top_n = top_n.strip()
        top_n = int(top_n) if top_n else None
        min_rating = float(min_rating)
        max_rating = float(max_rating)

        if min_rating < 0 or max_rating > 5:
            raise ValueError("Rating must be between 0 and 5.")
        if min_rating > max_rating:
            raise ValueError("Minimum rating cannot be greater than maximum rating.")

        # Merge the location restaurant data with Google and TripAdvisor data
        combined_data = pd.merge(google_review_data, tripadvisor_data, on='Restaurant', how='inner')
        combined_data = pd.merge(combined_data, location_restaurant_data[['Restaurant', 'url']], on='Restaurant', how='inner')

        # Calculate the combined rating and total number of reviews
        combined_data['Combined Rating'] = (combined_data['Rating_x'] + combined_data['Rating_y']) / 2
        combined_data['Total Reviews'] = combined_data['Number of Reviews_x'] + combined_data['Number of Reviews_y']

        # Add the location column
        combined_data['Location'] = location

        # Remove duplicates to ensure each restaurant appears only once
        combined_data = combined_data.drop_duplicates(subset=['Restaurant'], keep='first')

        # Filter by rating range
        filtered_data = combined_data[(combined_data['Combined Rating'] >= min_rating) & (combined_data['Combined Rating'] <= max_rating)]

        # Sort by combined rating and total reviews
        sorted_data = filtered_data.sort_values(by=['Combined Rating', 'Total Reviews'], ascending=[False, False])

        # If top_n is specified, select the top N results
        if top_n:
            popular_restaurants = sorted_data[['Restaurant', 'Location', 'url', 'Total Reviews', 'Combined Rating']].head(top_n)
        else:
            popular_restaurants = sorted_data[['Restaurant', 'Location', 'url', 'Total Reviews', 'Combined Rating']]

        # Rename columns
        popular_restaurants = popular_restaurants.rename(columns={
            'Restaurant': 'Name',
            'Total Reviews': 'Number of Reviews',
            'Combined Rating': 'Average Rating'
        })

        # Add a ranking column
        popular_restaurants.reset_index(drop=True, inplace=True)
        popular_restaurants.index += 1
        popular_restaurants.index.name = 'Rank'

        # Convert the restaurant name and URL to clickable links
        popular_restaurants['url'] = popular_restaurants.apply(lambda row: f'<a href="{row["url"]}" target="_blank">{row["Name"]}</a>', axis=1)

        # Display the DataFrame as an HTML table with clickable links
        display(HTML(popular_restaurants[['Name', 'Location', 'Number of Reviews', 'Average Rating', 'url']].to_html(escape=False)))

    except ValueError as e:
        print(f"Error: {e}")
    except KeyError as e:
        print(f"Error: {e}")

# Create a dropdown menu for location selection
locations = ['Ipoh', 'JB', 'KL', 'Kuching', 'Langkawi', 'Melaka', 'Miri', 'Penang', 'Petaling Jaya', 'Shah Alam']
dropdown_location = widgets.Dropdown(
    options=locations,
    value='KL',  # Default value
    description='Location:',
)

# Create a text input for number of top results
text_input_top_n = widgets.Text(
    value='',  # Default value is empty
    description='Top N:',
    style={'description_width': 'initial'}
)

# Create text inputs for rating range
text_input_min_rating = widgets.Text(
    value='0',  # Default value
    description='Min Rating:',
    style={'description_width': 'initial'}
)

text_input_max_rating = widgets.Text(
    value='5',  # Default value
    description='Max Rating:',
    style={'description_width': 'initial'}
)

# Display the widgets and link them to the update_display function
widgets.interactive(update_display, location=dropdown_location, top_n=text_input_top_n, min_rating=text_input_min_rating, max_rating=text_input_max_rating)

import pandas as pd
import ipywidgets as widgets
from IPython.display import display, HTML

# Load the GoogleReview and TripAdvisor datasets
google_review_data = pd.read_csv('GoogleReview_data_cleaned.csv')
tripadvisor_data = pd.read_csv('TripAdvisor_data_cleaned.csv')

# Clean datasets
google_review_data.dropna(axis=0, how='any', inplace=True)
tripadvisor_data.dropna(axis=0, how='any', inplace=True)
google_review_data.drop_duplicates(inplace=True, keep='first')
tripadvisor_data.drop_duplicates(inplace=True, keep='first')

# Add 'Number of Reviews' columns if not present in the datasets
if 'Number of Reviews' not in google_review_data.columns:
    google_review_data['Number of Reviews'] = google_review_data['Review'].apply(lambda x: len(x.split()) if isinstance(x, str) else 0)
if 'Number of Reviews' not in tripadvisor_data.columns:
    tripadvisor_data['Number of Reviews'] = tripadvisor_data['Review'].apply(lambda x: len(x.split()) if isinstance(x, str) else 0)

# Map the location to the respective CSV file
location_csv_map = {
    'Ipoh': 'Restaurants_Ipoh.csv',
    'JB': 'Restaurants_JB.csv',
    'KL': 'Restaurants_KL.csv',
    'Kuching': 'Restaurants_Kuching.csv',
    'Langkawi': 'Restaurants_Langkawi.csv',
    'Melaka': 'Restaurants_Melaka.csv',
    'Miri': 'Restaurants_Miri.csv',
    'Penang': 'Restaurants_Penang.csv',
    'Petaling Jaya': 'Restaurants_Petaling Jaya.csv',
    'Shah Alam': 'Restaurants_Shah Alam.csv'
}

# Define a function to update and display the data
def update_display(location, top_n, min_rating, max_rating):
    try:
        # Load the location-specific restaurant data
        location_file = location_csv_map.get(location)
        if not location_file:
            print("Invalid location.")
            return

        # Load the restaurant data for the selected location
        location_restaurant_data = pd.read_csv(location_file)

        # Ensure that the user input is valid
        top_n = top_n.strip()
        top_n = int(top_n) if top_n else None
        min_rating = float(min_rating)
        max_rating = float(max_rating)

        if min_rating < 0 or max_rating > 5:
            raise ValueError("Rating must be between 0 and 5.")
        if min_rating > max_rating:
            raise ValueError("Minimum rating cannot be greater than maximum rating.")

        # Merge the location restaurant data with Google and TripAdvisor data
        combined_data = pd.merge(google_review_data, tripadvisor_data, on='Restaurant', how='inner')
        combined_data = pd.merge(combined_data, location_restaurant_data[['Restaurant', 'url']], on='Restaurant', how='inner')

        # Calculate the combined rating and total number of reviews
        combined_data['Combined Rating'] = (combined_data['Rating_x'] + combined_data['Rating_y']) / 2
        combined_data['Total Reviews'] = combined_data['Number of Reviews_x'] + combined_data['Number of Reviews_y']

        # Add the location column
        combined_data['Location'] = location

        # Remove duplicates to ensure each restaurant appears only once
        combined_data = combined_data.drop_duplicates(subset=['Restaurant'], keep='first')

        # Filter by rating range
        filtered_data = combined_data[(combined_data['Combined Rating'] >= min_rating) & (combined_data['Combined Rating'] <= max_rating)]

        # Sort by combined rating and total reviews
        sorted_data = filtered_data.sort_values(by=['Combined Rating', 'Total Reviews'], ascending=[False, False])

        # If top_n is specified, select the top N results
        if top_n:
            popular_restaurants = sorted_data[['Restaurant', 'Location', 'url', 'Total Reviews', 'Combined Rating']].head(top_n)
        else:
            popular_restaurants = sorted_data[['Restaurant', 'Location', 'url', 'Total Reviews', 'Combined Rating']]

        # Rename columns
        popular_restaurants = popular_restaurants.rename(columns={
            'Restaurant': 'Name',
            'Total Reviews': 'Number of Reviews',
            'Combined Rating': 'Average Rating'
        })

        # Add a ranking column
        popular_restaurants.reset_index(drop=True, inplace=True)
        popular_restaurants.index += 1
        popular_restaurants.index.name = 'Rank'

        # Convert the restaurant name and URL to clickable links
        popular_restaurants['url'] = popular_restaurants.apply(lambda row: f'<a href="{row["url"]}" target="_blank">{row["Name"]}</a>', axis=1)

        # Display the DataFrame as an HTML table with clickable links
        display(HTML(popular_restaurants[['Name', 'Location', 'Number of Reviews', 'Average Rating', 'url']].to_html(escape=False)))

        # Display reviews for the selected restaurant
        if popular_restaurants.empty:
            print("No restaurants found in the specified rating range and top N.")
            return

        # Get the selected restaurant name
        selected_restaurant = popular_restaurants.iloc[0]['Name']

        # Extract reviews for the selected restaurant
        google_reviews = google_review_data[google_review_data['Restaurant'] == selected_restaurant]
        tripadvisor_reviews = tripadvisor_data[tripadvisor_data['Restaurant'] == selected_restaurant]

        # Combine and display reviews
        if not google_reviews.empty:
            display(HTML(f"<h3>Google Reviews for {selected_restaurant}</h3>"))
            display(HTML(google_reviews[['Author', 'Review']].to_html(escape=False)))

        if not tripadvisor_reviews.empty:
            display(HTML(f"<h3>TripAdvisor Reviews for {selected_restaurant}</h3>"))
            display(HTML(tripadvisor_reviews[['Author', 'Review']].to_html(escape=False)))

    except ValueError as e:
        print(f"Error: {e}")
    except KeyError as e:
        print(f"Error: {e}")

# Create a dropdown menu for location selection
locations = ['Ipoh', 'JB', 'KL', 'Kuching', 'Langkawi', 'Melaka', 'Miri', 'Penang', 'Petaling Jaya', 'Shah Alam']
dropdown_location = widgets.Dropdown(
    options=locations,
    value='KL',  # Default value
    description='Location:',
)

# Create a text input for number of top results
text_input_top_n = widgets.Text(
    value='',  # Default value is empty
    description='Top N:',
    style={'description_width': 'initial'}
)

# Create text inputs for rating range
text_input_min_rating = widgets.Text(
    value='0',  # Default value
    description='Min Rating:',
    style={'description_width': 'initial'}
)

text_input_max_rating = widgets.Text(
    value='5',  # Default value
    description='Max Rating:',
    style={'description_width': 'initial'}
)

# Display the widgets and link them to the update_display function
widgets.interactive(update_display, location=dropdown_location, top_n=text_input_top_n, min_rating=text_input_min_rating, max_rating=text_input_max_rating)

import pandas as pd
import ipywidgets as widgets
from IPython.display import display, HTML

# Load the GoogleReview and TripAdvisor datasets
google_review_data = pd.read_csv('GoogleReview_data_cleaned.csv')
tripadvisor_data = pd.read_csv('TripAdvisor_data_cleaned.csv')

# Clean datasets
google_review_data.dropna(axis=0, how='any', inplace=True)
tripadvisor_data.dropna(axis=0, how='any', inplace=True)
google_review_data.drop_duplicates(inplace=True, keep='first')
tripadvisor_data.drop_duplicates(inplace=True, keep='first')

# Add 'Number of Reviews' columns if not present in the datasets
if 'Number of Reviews' not in google_review_data.columns:
    google_review_data['Number of Reviews'] = google_review_data['Review'].apply(lambda x: len(x.split()) if isinstance(x, str) else 0)
if 'Number of Reviews' not in tripadvisor_data.columns:
    tripadvisor_data['Number of Reviews'] = tripadvisor_data['Review'].apply(lambda x: len(x.split()) if isinstance(x, str) else 0)

# Map the location to the respective CSV file
location_csv_map = {
    'Ipoh': 'Restaurants_Ipoh.csv',
    'JB': 'Restaurants_JB.csv',
    'KL': 'Restaurants_KL.csv',
    'Kuching': 'Restaurants_Kuching.csv',
    'Langkawi': 'Restaurants_Langkawi.csv',
    'Melaka': 'Restaurants_Melaka.csv',
    'Miri': 'Restaurants_Miri.csv',
    'Penang': 'Restaurants_Penang.csv',
    'Petaling Jaya': 'Restaurants_Petaling Jaya.csv',
    'Shah Alam': 'Restaurants_Shah Alam.csv'
}

# Define a function to update and display the data
def update_display(location, top_n, min_rating, max_rating):
    try:
        # Load the location-specific restaurant data
        location_file = location_csv_map.get(location)
        if not location_file:
            print("Invalid location.")
            return

        # Load the restaurant data for the selected location
        location_restaurant_data = pd.read_csv(location_file)

        # Ensure that the user input is valid
        top_n = top_n.strip()
        top_n = int(top_n) if top_n else None
        min_rating = float(min_rating)
        max_rating = float(max_rating)

        if min_rating < 0 or max_rating > 5:
            raise ValueError("Rating must be between 0 and 5.")
        if min_rating > max_rating:
            raise ValueError("Minimum rating cannot be greater than maximum rating.")

        # Merge the location restaurant data with Google and TripAdvisor data
        combined_data = pd.merge(google_review_data, tripadvisor_data, on='Restaurant', how='inner')
        combined_data = pd.merge(combined_data, location_restaurant_data[['Restaurant', 'url']], on='Restaurant', how='inner')

        # Calculate the combined rating and total number of reviews
        combined_data['Combined Rating'] = (combined_data['Rating_x'] + combined_data['Rating_y']) / 2
        combined_data['Total Reviews'] = combined_data['Number of Reviews_x'] + combined_data['Number of Reviews_y']

        # Add the location column
        combined_data['Location'] = location

        # Remove duplicates to ensure each restaurant appears only once
        combined_data = combined_data.drop_duplicates(subset=['Restaurant'], keep='first')

        # Filter by rating range
        filtered_data = combined_data[(combined_data['Combined Rating'] >= min_rating) & (combined_data['Combined Rating'] <= max_rating)]

        # Sort by combined rating and total reviews
        sorted_data = filtered_data.sort_values(by=['Combined Rating', 'Total Reviews'], ascending=[False, False])

        # If top_n is specified, select the top N results
        if top_n:
            popular_restaurants = sorted_data[['Restaurant', 'Location', 'url', 'Total Reviews', 'Combined Rating']].head(top_n)
        else:
            popular_restaurants = sorted_data[['Restaurant', 'Location', 'url', 'Total Reviews', 'Combined Rating']]

        # Rename columns
        popular_restaurants = popular_restaurants.rename(columns={
            'Restaurant': 'Name',
            'Total Reviews': 'Number of Reviews',
            'Combined Rating': 'Average Rating'
        })

        # Add a ranking column
        popular_restaurants.reset_index(drop=True, inplace=True)
        popular_restaurants.index += 1
        popular_restaurants.index.name = 'Rank'

        # Convert the restaurant name and URL to clickable links
        popular_restaurants['url'] = popular_restaurants.apply(lambda row: f'<a href="{row["url"]}" target="_blank">{row["Name"]}</a>', axis=1)

        # Display the DataFrame as an HTML table with clickable links
        display(HTML(popular_restaurants[['Name', 'Location', 'Number of Reviews', 'Average Rating', 'url']].to_html(escape=False)))

        # Create a dropdown menu for restaurant selection
        restaurant_selector = widgets.Dropdown(
            options=[(row['Name'], row['Name']) for index, row in popular_restaurants.iterrows()],
            description='Select Restaurant:',
            disabled=False
        )

        def display_reviews(selected_restaurant):
            if selected_restaurant:
                # Extract reviews for the selected restaurant
                google_reviews = google_review_data[google_review_data['Restaurant'] == selected_restaurant]
                tripadvisor_reviews = tripadvisor_data[tripadvisor_data['Restaurant'] == selected_restaurant]

                # Clear previous review display
                display(HTML("<hr>"))

                # Display reviews
                if not google_reviews.empty:
                    display(HTML(f"<h3>Google Reviews for {selected_restaurant}</h3>"))
                    display(HTML(google_reviews[['Author', 'Review']].to_html(escape=False)))

                if not tripadvisor_reviews.empty:
                    display(HTML(f"<h3>TripAdvisor Reviews for {selected_restaurant}</h3>"))
                    display(HTML(tripadvisor_reviews[['Author', 'Title', 'Review', 'Dates']].to_html(escape=False)))
            else:
                print("No restaurant selected.")

        # Link the restaurant selector to the display_reviews function
        display(restaurant_selector)
        widgets.interactive(display_reviews, selected_restaurant=restaurant_selector)

    except ValueError as e:
        print(f"Error: {e}")
    except KeyError as e:
        print(f"Error: {e}")

# Create a dropdown menu for location selection
locations = ['Ipoh', 'JB', 'KL', 'Kuching', 'Langkawi', 'Melaka', 'Miri', 'Penang', 'Petaling Jaya', 'Shah Alam']
dropdown_location = widgets.Dropdown(
    options=locations,
    value='KL',  # Default value
    description='Location:',
)

# Create a text input for number of top results
text_input_top_n = widgets.Text(
    value='',  # Default value is empty
    description='Top N:',
    style={'description_width': 'initial'}
)

# Create text inputs for rating range
text_input_min_rating = widgets.Text(
    value='0',  # Default value
    description='Min Rating:',
    style={'description_width': 'initial'}
)

text_input_max_rating = widgets.Text(
    value='5',  # Default value
    description='Max Rating:',
    style={'description_width': 'initial'}
)

# Display the widgets and link them to the update_display function
widgets.interactive(update_display, location=dropdown_location, top_n=text_input_top_n, min_rating=text_input_min_rating, max_rating=text_input_max_rating)